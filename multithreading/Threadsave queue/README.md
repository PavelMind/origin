### Курсовой проект "Потокобезопасная очередь"(Пул потоков на базе потокобезопасной очереди)
Что было нужно сделать:
- Создать потокобезопасную очередь, хранящую функции, предназначенные для исполнения.
- На основе этой очереди реализовать пул потоков. Этот пул состоит из фиксированного числа рабочих потоков, равного количеству аппаратных ядер.
- Когда у программы появляется какая-то работа, она вызывает функцию, которая помещает эту работу в очередь.
- Рабочий поток забирает работу из очереди, выполняет указанную в ней задачу, после чего проверяет, есть ли в очереди другие работы.

Необходимые классы
1. Класс thread_pool — реализация пула потоков. Содержит вектор потоков и потокобезопасную очередь задач.  
Минимально требуемые методы класса thread_pool:
- work — выбирает из очереди очередную задачу и исполняет её. Этот метод передаётся конструктору потоков для исполнения;
- submit — помещает в очередь задачу.

1. Шаблонный класс safe_queue — реализация очереди, безопасной относительно одновременного доступа из нескольких потоков. Он должен содержать очередь std::queue для хранения задач.  
Минимальные методы:
- push — записывает в начало очереди новую задачу;
- pop — находится в ожидании, пока не придёт уведомление на условную переменную.

#### Что было сделано.
Данная реализация наивная, то есть простая. Во время выполнения этой работы некоторые вещи были неизвестны, поэтому тут используется std::function для функций только сигнатуры void(void). В дипломной работе есть реализация пула потоков уже приличная, для любых сигнатур и возвратом результата ([пул в дипломной работе](https://github.com/PavelMind/origin/tree/main/diploma%20thesis%20-%20Crawler/Crawler/threads%20pool))

Класс thread_pool в этой работе содержит вектор потоков, которые создаются при создании класса. Во все эти потоки передаётся метод work(), выполняющий переданную в пул пользовательскую функцию, извлекаемую из очереди.  
Класс thread_pool содержит атомарный счётчик количества потоков maxThread. Также он совместно с классом safe_queue содержит флаги завершения работы пула с именами toStopThread. При вызове деструктора thread_pool оба флага устанавливаются в true, что приводит к остановке метода work() в потоках как уже работающих, так и заблокированных в методе pop() потокобезопасной очереди функций (через std::condition_variable). После чего прекращение работы work() снижает счётчик потоков maxThread на 1, а деструктор ожидает в течении времени, пока счётчик не обнулится, что означает завершение работы всех функций. Работающие пользовательские задачи, переданные в пул, доработают до конца.  
Такая реализация для того, чтоб смерть пула вызывала смерть содержимого, где бы не случилась. Потоки открепляются от основного через std::thread::detach().

Метод work(), выполняющийся в потоках пытается забрать функцию из класса потокобезопасной очереди safe_queue и блокируется в safe_queue::pop(), когда пользовательских функций нет во внутренней очереди `std::queue<std::function<void(void)>> Queue`. При помещении новой функции в очередь через метод push() все потоки, остановившиеся в pop(), оповещаются об этом.